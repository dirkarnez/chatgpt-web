
<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flexboxgrid/6.3.1/flexboxgrid.min.css" type="text/css">
	<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
	<script src="https://github.com/dirkarnez/webpack-umd-action/releases/download/eventsource-parser.0.1.0/eventsource-parser.0.1.0.min.js"></script>
	<script>
		window.key = "OPENAI";
	</script>
	<style>
		.my-container {
		    -webkit-box-sizing: border-box;
		       -moz-box-sizing: border-box;
			    box-sizing: border-box;
		}

		textarea {
			width: 100%;
			-webkit-box-sizing: border-box;
				-moz-box-sizing: border-box;
				    box-sizing: border-box;
		}
		.my-container {
			padding: 10px;
		}
	</style>
</head>

<body>
	<div class="row my-container">
		<div style="width: 100%;">		
			<textarea id="ask-textarea"></textarea>
			<button onclick="handleClick()">Ask</button><br>
			<div id="ans">
			<input type="text" id="key" oninput="Cookies.set(window.key, event.target.value)">
		</div>
	</div>



	
	<script>
		if (!ReadableStream.prototype[Symbol.asyncIterator]) {
			ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
				const reader = this.getReader();
				try {
					while (true) {
						const { done, value } = await reader.read();
						if (done) {
							return;
						}
						yield value;
					}
				}
				finally {
					reader.releaseLock();
				}
			}
		}

		async function OpenAIStream() {
			const encoder = new TextEncoder();
			const decoder = new TextDecoder();

			let counter = 0;
			const res = fetch("https://api.openai.com/v1/completions", {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				headers: {
					'Content-Type': 'application/json',
					'Authorization': `Bearer ${Cookies.get(window.key)}`,
				},
				body: JSON.stringify({
					// model:"text-chat-davinci-002-20230126",
					// model:"text-chat-davinci-003",

					model: "text-davinci-003",
					// model:"text-curie-001",
					prompt: document.getElementById("ask-textarea").innerText, //"what is the difference between fourier transform and laplace transform?",
					temperature: 0.7,
					top_p: 1,
					frequency_penalty: 0,
					presence_penalty: 0,
					max_tokens: 500,
					stream: true,
					n: 1,
				}) // body data type must match "Content-Type" header
			});

			const stream = new ReadableStream({
				async start(controller) {
					// callback
					function onParse(event) {
						if (event.type === "event") {
							const data = event.data;
							// https://beta.openai.com/docs/api-reference/completions/create#completions/create-stream
							if (data === "[DONE]") {
								controller.close();
								return;
							}
							try {
								const json = JSON.parse(data);
								const text = json.choices[0].text;
								if (counter < 2 && (text.match(/\n/) || []).length) {
									// this is a prefix character (i.e., "\n\n"), do nothing
									return;
								}
								const queue = encoder.encode(text);
								controller.enqueue(queue);
								counter++;
							} catch (e) {
								// maybe parse error
								controller.error(e);
							}
						}
					}

					// stream response (SSE) from OpenAI may be fragmented into multiple chunks
					// this ensures we properly read chunks and invoke an event for each SSE event stream
					const parser = window.eventsourceParser.createParser(onParse);
					// https://web.dev/streams/#asynchronous-iteration

					res.then(async r => {
						for await (const chunk of r.body) {
							parser.feed(decoder.decode(chunk));
						}
					})
				},
			});

			return new Response(stream);
		}

		function handleClick() {
			document.getElementById("ans").innerText = "";
			
			OpenAIStream().then(async response => {
				const data = response.body;
				if (!data) {

				}
				const decoder = new TextDecoder();

				for await (const chunk of data) {
					document.getElementById("ans").innerText += decoder.decode(chunk);
				}
			});
		}
		
		document.getElementById("key").value = Cookies.get(window.key) || "";
	</script>
</body>

</html>
